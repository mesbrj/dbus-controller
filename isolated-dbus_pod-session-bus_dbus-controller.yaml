apiVersion: v1
kind: Pod
metadata:
  name: isolated-dbus-controller-pod
  labels:
    app: isolated-dbus-controller
    environment: production
spec:
  restartPolicy: Always
  # Shared volume for D-Bus socket communication between containers
  volumes:
    - name: dbus-session-socket
      emptyDir: {}  # Regular disk-based emptyDir for better compatibility
  containers:
    # Isolated D-Bus Session Daemon - secure, pod-scoped
    - name: isolated-dbus-session
      image: localhost/isolated-dbus:latest  # Custom image with D-Bus pre-installed
      securityContext:
        allowPrivilegeEscalation: false
        runAsUser: 1000
        runAsGroup: 1000
        capabilities:
          drop:
            - ALL
      command:
        - /bin/bash
        - -c
        - |
          echo "=== Isolated D-Bus Session Setup ==="
          echo "Using pre-installed D-Bus from custom image"
          
          # Create user home directory and D-Bus config
          mkdir -p /tmp/dbus-home/.config/dbus-1/session.d
          export HOME=/tmp/dbus-home
          
          # Create shared socket directory
          mkdir -p /shared/dbus
          chmod 755 /shared/dbus
          
          # Start isolated session bus with custom socket location
          export DBUS_SESSION_BUS_ADDRESS="unix:path=/shared/dbus/session_bus_socket"
          
          echo "Starting isolated D-Bus session daemon..."
          echo "Bus address: $DBUS_SESSION_BUS_ADDRESS"
          
          # Start D-Bus session daemon
          dbus-daemon --session \
            --address="$DBUS_SESSION_BUS_ADDRESS" \
            --nofork \
            --print-pid &
          
          DBUS_PID=$!
          echo "Isolated D-Bus session daemon started with PID: $DBUS_PID"
          
          # Wait for socket to be created
          for i in {1..30}; do
            if [ -S /shared/dbus/session_bus_socket ]; then
              echo "D-Bus socket created successfully"
              break
            fi
            echo "Waiting for D-Bus socket... ($i/30)"
            sleep 1
          done
          
          # Keep container alive and monitor daemon
          echo "D-Bus daemon monitoring started..."
          while kill -0 $DBUS_PID 2>/dev/null; do
            sleep 5
          done
          echo "D-Bus session daemon stopped"
      volumeMounts:
        - name: dbus-session-socket
          mountPath: /shared/dbus
      env:
        - name: DBUS_SESSION_BUS_ADDRESS
          value: "unix:path=/shared/dbus/session_bus_socket"
      resources:
        requests:
          memory: "32Mi"
          cpu: "50m"
        limits:
          memory: "64Mi"
          cpu: "100m"

    # D-Bus Controller Application - secure, non-root, with pre-built app
    - name: dbus-controller
      image: localhost/dbus-controller:latest  # Custom image with D-Bus and dbus-controller application pre-built
      securityContext:
        allowPrivilegeEscalation: false
        runAsUser: 1000
        runAsGroup: 1000
        capabilities:
          drop:
            - ALL
      command:
        - /bin/bash
        - -c
        - |
          # Set up writable workspace for OpenAPI docs
          cd /tmp/docs
          mkdir -p docs
          
          echo "=== D-Bus Controller Application ==="
          echo "Using custom image with pre-built D-Bus controller application"
          
          # Wait for D-Bus session daemon
          echo "Waiting for isolated D-Bus session..."
          while [ ! -S /shared/dbus/session_bus_socket ]; do
            echo "  Waiting for D-Bus socket..."
            sleep 2
          done
          
          export DBUS_SESSION_BUS_ADDRESS="unix:path=/shared/dbus/session_bus_socket"
          echo "Connected to session bus: $DBUS_SESSION_BUS_ADDRESS"
          
          echo "Testing D-Bus connectivity..."
          dbus-send --session --print-reply --dest=org.freedesktop.DBus /org/freedesktop/DBus org.freedesktop.DBus.ListNames || echo "D-Bus test completed"
          
          echo "Starting D-Bus Controller API..."
          /usr/local/bin/dbus-controller &
          API_PID=$!
          
          # Wait for API to be ready
          echo "Waiting for API to start..."
          for i in {1..30}; do
            if curl -s -f http://localhost:8080/buses >/dev/null 2>&1; then
              echo "API is ready!"
              break
            fi
            echo "Waiting for API... ($i/30)"
            sleep 1
          done
          
          echo "Testing API endpoints..."
          echo "=== Available buses ==="
          curl -s http://localhost:8080/buses | jq '.' 2>/dev/null || curl -s http://localhost:8080/buses
          
          echo -e "\n=== Session bus services ==="
          curl -s http://localhost:8080/buses/session/services | jq '. | length' 2>/dev/null || curl -s http://localhost:8080/buses/session/services
          
          echo -e "\n=== API Documentation ==="
          echo "OpenAPI spec: http://localhost:8080/swagger/openapi.json"
          echo "Swagger UI: http://localhost:8080/swagger/index.html"

          echo -e "\n=== Fetching OpenAPI spec ==="
          curl -s http://localhost:8080/swagger/openapi.json | jq || echo "Failed to parse OpenAPI spec"

          echo -e "\n=== API is running ==="
          echo "Access the API at: http://localhost:8080"
          wait $API_PID
      volumeMounts:
        - name: dbus-session-socket
          mountPath: /shared/dbus
      env:
        - name: DBUS_SESSION_BUS_ADDRESS
          value: "unix:path=/shared/dbus/session_bus_socket"
        - name: CGO_ENABLED
          value: "0"
        - name: GOOS
          value: "linux"
      resources:
        requests:
          memory: "256Mi"
          cpu: "100m"
        limits:
          memory: "512Mi"
          cpu: "200m"
